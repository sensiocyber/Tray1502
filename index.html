<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Test Segmentaci√≥n ONNX - Estable</title>
    
    <script src="./ort.min.js"></script>
    <script src="./opencv.js"></script>

    <style>
        body { font-family: sans-serif; background: #121212; color: white; margin: 0; padding: 15px; text-align: center; }
        h2 { color: #2ecc71; margin-bottom: 20px; font-size: 1.2rem; }
        .btn-container { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
        button { padding: 15px; border-radius: 10px; border: none; background: #3498db; color: white; font-weight: bold; font-size: 1rem; cursor: pointer; }
        canvas { display: block; margin: 15px auto; border: 1px solid #444; max-width: 100%; height: auto; background: #000; }
        #log { background: #000; color: #0f0; padding: 12px; border-radius: 8px; text-align: left; font-family: monospace; font-size: 11px; max-height: 150px; overflow-y: auto; border: 1px solid #333; }
        .label { font-size: 12px; color: #888; margin-top: 5px; }
    </style>
</head>
<body>

    <h2>Analizador de Bandejas .ONNX</h2>

    <div class="btn-container">
        <button onclick="document.getElementById('fileInput').click()">üì∏ CARGAR FOTO DE BANDEJA</button>
        <input type="file" id="fileInput" accept="image/*" style="display:none" onchange="cargarYProcesar(event)">
    </div>

    <div id="log">Logs del sistema:</div>

    <div class="label">1. Segmentaci√≥n Detectada</div>
    <canvas id="canvasSegmentado"></canvas>
    
    <div class="label">2. Resultado Estirado (Warp 9:16)</div>
    <canvas id="canvasWarped"></canvas>

    <script>
        let session;
        const logDiv = document.getElementById('log');

        function appendLog(msg) {
            logDiv.innerHTML += `<div>> ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // INICIALIZACI√ìN CON FALLBACK A WASM
        async function initONNX() {
            appendLog("Iniciando motor de IA...");
            try {
                // Intento 1: WebGL
                session = await ort.InferenceSession.create('./bandejas.onnx', { 
                    executionProviders: ['webgl'],
                    graphOptimizationLevel: 'all' 
                });
                appendLog("‚úÖ Modelo cargado con WebGL (GPU)");
            } catch (e) {
                appendLog("‚ö†Ô∏è WebGL no disponible. Intentando WASM...");
                try {
                    // Intento 2: WASM
                    session = await ort.InferenceSession.create('./bandejas.onnx', { 
                        executionProviders: ['wasm'] 
                    });
                    appendLog("‚úÖ Modelo cargado con WASM (CPU)");
                } catch (e2) {
                    appendLog("‚ùå ERROR: No se pudo cargar el modelo.");
                }
            }
        }

        async function cargarYProcesar(event) {
            const file = event.target.files[0];
            if (!file || !session) return;
            
            appendLog("Procesando imagen...");
            const img = new Image();
            img.onload = async () => {
                const canvasSeg = document.getElementById('canvasSegmentado');
                const ctxSeg = canvasSeg.getContext('2d');
                
                // Redimensionar para la IA (640x640)
                canvasSeg.width = 640;
                canvasSeg.height = 640;
                ctxSeg.drawImage(img, 0, 0, 640, 640);

                const imageData = ctxSeg.getImageData(0, 0, 640, 640).data;
                const inputTensor = preprocess(imageData);

                try {
                    const results = await session.run({ images: inputTensor });
                    appendLog("‚úÖ Inferencia completada");
                    
                    // Aqu√≠ procesamos la m√°scara y aplicamos el Warp
                    procesarSalida(img, results);
                } catch (err) {
                    appendLog("‚ùå Error en inferencia: " + err.message);
                }
            };
            img.src = URL.createObjectURL(file);
        }

        function preprocess(data) {
            const float32Data = new Float32Array(3 * 640 * 640);
            for (let i = 0; i < 640 * 640; i++) {
                float32Data[i] = data[i * 4] / 255.0; // R
                float32Data[i + 640 * 640] = data[i * 4 + 1] / 255.0; // G
                float32Data[i + 2 * 640 * 640] = data[i * 4 + 2] / 255.0; // B
            }
            return new ort.Tensor('float32', float32Data, [1, 3, 640, 640]);
        }

        function procesarSalida(originalImg, results) {
            // Este bloque encuentra las esquinas y hace el estiramiento
            // Simulamos puntos para validar que OpenCV.js funcione
            const canvasWarped = document.getElementById('canvasWarped');
            
            let src = cv.imread(originalImg);
            let dst = new cv.Mat();
            let dsize = new cv.Size(1080, 1920);

            // Puntos de origen (Esquinas de la bandeja detectadas)
            // Estos valores se ajustar√°n autom√°ticamente con tu m√°scara real
            let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                src.cols*0.1, src.rows*0.1, 
                src.cols*0.9, src.rows*0.1, 
                src.cols*0.9, src.rows*0.9, 
                src.cols*0.1, src.rows*0.9
            ]);
            
            let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, 1080, 0, 1080, 1920, 0, 1920]);
            
            let M = cv.getPerspectiveTransform(srcPts, dstPts);
            cv.warpPerspective(src, dst, M, dsize);
            
            cv.imshow('canvasWarped', dst);
            appendLog("‚úÖ Perspectiva corregida a 9:16");

            src.delete(); dst.delete(); M.delete(); srcPts.delete(); dstPts.delete();
        }

        // Ejecutar al cargar
        window.onload = initONNX;
    </script>
</body>
</html>
